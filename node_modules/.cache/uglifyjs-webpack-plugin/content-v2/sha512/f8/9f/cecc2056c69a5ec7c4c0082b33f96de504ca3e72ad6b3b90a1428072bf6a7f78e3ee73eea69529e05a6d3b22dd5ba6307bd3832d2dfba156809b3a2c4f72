{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"/Users/brad/Desktop/Neural Networks/nn-tictactoe/src/nn.js\",\"/Users/brad/Desktop/Neural Networks/nn-tictactoe/src/main.js\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"configurable\",\"enumerable\",\"get\",\"r\",\"value\",\"n\",\"__esModule\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"$\",\"document\",\"ready\"],\"mappings\":\"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,OAAA,KAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,GAAAA,EAAAmB,WACA,WAA2B,OAAAnB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDxB,EAAA2B,EAAA,IAIA3B,EAAAA,EAAA4B,EAAA,qCClEe5B,EAAQ,oCCATA,EAAQ,GACAA,EAAQ,GAc9B6B,EAAEC,UAAUC,MAAM\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"/\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 3);\\n\",\"/* global require */\\nconst Matrix = require('./matrix.js');\\n\\n// The sigmoid function\\nfunction sigmoid(x) {\\n  return (1 / (1 + Math.exp(-x)))*2-1;\\n}\\n\\n// The derivative of the sigmoid\\nfunction dsigmoid(y) {\\n  return (y * (1 - y))*2;\\n}\\n\\nclass NeuralNetwork {\\n  constructor(numI, numH, numO) {\\n    this.input_nodes = numI;\\n    this.hidden_nodes = numH;\\n    this.output_nodes = numO;\\n\\n    this.weights_ih = new Matrix(this.hidden_nodes, this.input_nodes);\\n    this.weights_ho = new Matrix(this.output_nodes, this.hidden_nodes);\\n    this.weights_ih.randomize();\\n    this.weights_ho.randomize();\\n\\n    this.bias_h = new Matrix(this.hidden_nodes,1);\\n    this.bias_o = new Matrix(this.output_nodes,1);\\n    this.bias_h.randomize();\\n    this.bias_o.randomize();\\n\\n    this.learning_constant = 0.1;\\n\\n    this.total_trainings = 0;\\n  }\\n\\n  // This function generates its guess based upon inputs\\n  feedForward(input_array) {\\n    // Convert input_array to Matrix\\n    let inputs = Matrix.fromArray(input_array);\\n\\n    // Generate hidden layer values\\n    let hidden = Matrix.multiply(this.weights_ih, inputs);\\n    // Add bias\\n    hidden.add(this.bias_h);\\n    // Apply activation function\\n    hidden.map(sigmoid);\\n\\n    // Generating final output\\n    let output = Matrix.multiply(this.weights_ho, hidden);\\n    //Add bias\\n    output.add(this.bias_o);\\n    // Apply activation function\\n    output.map(sigmoid);\\n\\n    // Returning output as an Array\\n    return output.toArray();\\n  }\\n\\n  // This function modifies the weights and bias based upon the expected output using gradient descent\\n  train(input_array, target_array) {\\n    // Convert input_array to Matrix\\n    let inputs = Matrix.fromArray(input_array);\\n\\n    // Generate hidden layer values\\n    let hidden = Matrix.multiply(this.weights_ih, inputs);\\n    // Add bias\\n    hidden.add(this.bias_h);\\n    // Apply activation function\\n    hidden.map(sigmoid);\\n\\n    // Generating final output\\n    let outputs = Matrix.multiply(this.weights_ho, hidden);\\n    // Add bias\\n    outputs.add(this.bias_o);\\n    // Apply activation function\\n    outputs.map(sigmoid);\\n\\n    // Convert array to matrix\\n    let targets = Matrix.fromArray(target_array);\\n    // Calculate output errors\\n    let output_errors = Matrix.subtract(targets, outputs);\\n\\n    // Calculate gradient\\n    let gradients = Matrix.map(outputs, dsigmoid);\\n    gradients.multiply(output_errors);\\n    gradients.multiply(this.learning_constant);\\n\\n    // Calculate deltas\\n    let hidden_T = Matrix.transpose(hidden);\\n    let weight_ho_deltas = Matrix.multiply(gradients, hidden_T);\\n\\n    // Adjust weights with deltas\\n    this.weights_ho.add(weight_ho_deltas);\\n    // Adjust bias with gradients\\n    this.bias_o.add(gradients);\\n\\n    // Calculate hidden layer error\\n    let who_t = Matrix.transpose(this.weights_ho);\\n    let hidden_errors = Matrix.multiply(who_t, output_errors);\\n\\n    // Calculate hidden gradient\\n    let hidden_gradient = Matrix.map(hidden, dsigmoid);\\n    hidden_gradient.multiply(hidden_errors);\\n    hidden_gradient.multiply(this.learning_constant);\\n\\n    // Calculate deltas\\n    let inputs_T = Matrix.transpose(inputs);\\n    let weight_ih_deltas = Matrix.multiply(hidden_gradient, inputs_T);\\n\\n    // Adjust weights with deltas\\n    this.weights_ih.add(weight_ih_deltas);\\n    // Adjust bias with gradient\\n    this.bias_h.add(hidden_gradient);\\n  }\\n}\\n\",\"/* global require */\\nconst Board = require('./board.js');\\nconst NeuralNetwork = require('./nn.js');\\n\\n// Define network shape\\nconst input_size = 9;\\nconst hidden_size = 18;\\nconst output_size = 9;\\n\\nlet board_amount;\\nlet global_networks;\\n// let board;\\n// let learningBoard;\\n// let networks;\\n// let outputs;\\n\\n$(document).ready(function() {\\n  // board = new Board();\\n  // learningBoard = new Board();\\n});\\n\\nfunction playerMove(index) {\\n  // board.playMove(board.human, index)\\n  // learningBoard.playMove(board.human, index)\\n  // nnMove();\\n}\\n\\n// function nnMove() {\\n//   let normalizedInputs = [];\\n//\\n//   board.moves.map((move, i) => {\\n//     if(move === board.human) {\\n//       normalizedInputs[i] = -1;\\n//     } else if(move === board.computer) {\\n//       normalizedInputs[i] = 1;\\n//     } else {\\n//       normalizedInputs[i] = 0;\\n//     }\\n//   });\\n//\\n//   if(normalizedInputs.length !== 9) {\\n//     console.log(\\\"Normalized inputs length only \\\" + normalizedInputs.length);\\n//   }\\n//\\n//   // Creates new networks\\n//   for(let i = 0; i < 10; i++) {\\n//     networks[i] = new NeuralNetwork(9,12,9);\\n//   }\\n//\\n//   // Generates outputs for all networks\\n//   networks.map((nn, i) => {\\n//     outputs[i] = nn.feedForward(normalizedInputs);\\n//   });\\n//\\n//   // Get highest scoring move for each network\\n//   let highestMove = { index: 0, score: 0 };\\n//   outputs.map((output, i) => {\\n//     output.map((score, i) => {\\n//       if(score > highestMove.score) {\\n//         highestMove.score = score;\\n//         highestMove.index = i;\\n//       }\\n//     })\\n//     optimalMoves[i] = { index: highestScoringIndex, score: highestScore };\\n//   });\\n//\\n//   // Get Highest Scoring Optimal Move\\n//   highestMove = { index: 0, score: 0 };\\n//   optimalMoves.map((move, i) => {\\n//     if(move.score > highestMove.score) {\\n//       highestMove = move;\\n//     }\\n//   });\\n// }\\n\\nfunction initBoards(amount_boards) {\\n  let num_networks = amount_boards * 2;\\n  board_amount = amount_boards;\\n  global_networks = createNN(num_networks, input_size, hidden_size, output_size);\\n}\\n\\nfunction createNN(amount_ns, i_amount, h_amount, o_amount) {\\n  let array = [];\\n  for(let i = 0; i < amount_ns; i++) {\\n    array.push(new NeuralNetwork(i_amount, h_amount, o_amount));\\n  }\\n  return array;\\n}\\n\"]}","code":"!function(n){var e={};function t(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return n[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:r})},t.r=function(n){Object.defineProperty(n,\"__esModule\",{value:!0})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,\"a\",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p=\"/\",t(t.s=3)}([function(n,e){},function(n,e,t){t(0)},function(n,e){},function(n,e,t){t(2),t(1);$(document).ready(function(){})}]);","extractedComments":[]}